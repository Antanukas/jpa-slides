<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Java Persistence Api</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        <section data-background-image="bg.png">
          <h2>Darbas su duomenų bazėmis - JPA</h2>
          Antanas Bastys

        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Object-Relational Impedence mismatch

                - objektinio modelio neatitikimias reliaciniui
                - objektinis modelis įsivaizduojamas kaip grafas
                - reliacinis modelis įsiviazduojamas kaip lenteliės (Pvz 'Excel' lentelės)
                - kyla 5 pagrinidiniai nesutapimai bandant išsaugoti objektinį modelį reliaciniame
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Object-Relational Impedence mismatch

                - Detalumas: daugiau klasių nei lentelių (adresas)
                - Paveldimumas: ar girdėjote apie tėvines lenteles? :)
                - Lygybė: pirminis raktas prieš `==` ir `equals`
                - Sąryšiai: objektiniame vienpusiai, o reliaciniame dvipusiai
                - Navigacija per duomenis: objektiniai reikia vaiksčioti nuo šaknies
                per sąryšius, o reliacinemiai per `JOIN` sąlygas
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### ORM

                - ORM - Object Relational Mapping
                - Būdas susieti reliacines duomenų bazes su objektinėmis duomenų struktūromis
                - JPA - Standartas apibrėžiantis, kaip ORM biblioteka turi vieikti
                - JPA implementacijos: Hibernate, EclipseLink, kitos
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Privalumai

                - Java duomenų klasės automatiškai susiejamos su reliacinu modeliu
                - Paslepia duomenų bazės struktūrą
                - Lengviau dirbti su keliomis reliacinių bazių implementacijomis
                - Palyginus su pliku JDBC žymiai mažiau `boilerplate` kodo
                - Supraprastina sudėtingesnių objektų grafų užkrovimą
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Trūkumai

                - Labai sudėtinga bibliotekos implementacija
                - Dažnai kažkas 'magiškai' pradeda veikti vien uždėjus anotaciją
                - Beveik visada sudėtingesniais atvejais darbas su duomenų baze
                tampa neoptimalus ir reikalauja gilesnių žinių apie ORM biblioteką
                - Sudėtingesniais atvejais išlenda faktas, jog naudojama realiacinė duomenų bazė
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### JPA - `EntityManager`

                - find(Class,Object) - surasti objektą pagal pirminį raktą
                - persist(Object) - išsaugoti ir pradėti valdyti objektą
                - merge(Object) - išsaugoti objekto pakeitimus
                - refresh(Object) - gauti objekto pasikeitimus iš DB
                - remove(Object) - pašalinti objektą

            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
          #### JPA - Esybės (entities)

          ```
          @Entity
          public class Good {
              @Id
              @GeneratedValue(strategy = GenerationType.AUTO)
              private Integer id;
              private String name;
            // geteriai ir seteriai
          }

          ```

          - Saugomas lentelėje 'Good'
          - id laukas - pirminis raktas
          - turi 2 stulpelius - id ir name
          - id laukas automatiskai generuojamas išsaugant naują įrašą
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### JPA - JPQL

                - Java Persistence Query Language
                - panašu į SQL
                - rašant join'us siejama ne per pirminį raktą, o per lauką klasėje
                - refresh(Object) - gauti objekto pasikeitimus iš DB
                - remove(Object) - pašalinti objektą

            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
              #### JPA -JPQL pavyzdys

              ```
              Query q = entityManager.createQuery("select g from Good g");
              List<Good> goods = q.getResultList();
              ```
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
              #### Integracija su Spring

              ```
              <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-data-jpa</artifactId>
              </dependency>
              ```

              Pagal nutylėjima JPA implementacija yra Hibernate
              Startuojant aplikacijai Hibernate automatiškai sukuria trūkstamus schemos elementus duomenų bazėje
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
              #### Integracija su Spring

              ```
              @Autowired
              private javax.persistence.EntityManager em;
              ```

            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
              #### Spring Transakcijos

              ```
              @Transactional
              public void someMethod() {
                // Do stuff with db
              }
              ```
              Anotavus Spring karkasas pasirūpina, kad prieš kviečiant metodą transakcija būtų pradėta ir pasibaigus pakeitimai iššsaugoti
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
              #### Spring Transakcijos

              - Jei trankacijos vykdymo metu iššaukiamas `RuntimeException`
              pakeitimai duomenų bazėje atšaukiami
              - Programiškai galima rollback'inti

              ```
              TransactionAspectSupport.currentTransactionStatus()
                .setRollbackOnly()
              ```

              - Transakcijos pabaigoje pakeitimai valdomiems objektas autmatiškai išsaugomi
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
              #### Spring Lygių architektūra

              - `@Controller` klasės atsakingos už REST Api mappinga (@GetMapping, @PostMapping)
              - `@Service` klasės atsakingos už verslo logiką
              - `@Repository` klasės atsakingos už darbą su duomenų bazėm - SQL užklausos
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
              #### Spring Lygių architektūra

              - Tradicinė Web aplikacija Spring karkase turi šių lygių klases
              - Paprastais atvejais JPA `@Entity` klasės taip pat naudojamos kaip serverio atsakymai
              - Sudėtingesniais atvejais `@Entity` klasės priklauso `@Repository` lygiui, o `@Service` lygis turi atskirą modelį
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
              #### Duomenų bazė

              ```
              <dependency>
                <groupId>com.h2database</groupId>
                <artifactId>h2</artifactId>
                <scope>runtime</scope>
              </dependency>
              ```

              - Demo tikslais naudosime H2 realiacinė duomenų bazę
              - Duomenų bazė bus Java proceso atmintyje
              - Perkrovus Java procesą duomenys dings
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
              #### Duomenų bazė - H2 Console

              - Spring Boot automatiškai paleidžia H2 Console naudojant H2 bazę
              - http://localhost:8080/h2-console

              ```
              jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
              ```

            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Užduotis 1 produktų administravimas

                - Sukurkite 3 REST endpointus:
                  - GET /products - sąrašas produktų
                  - POST /products - sukurimas naujo produkto
                  - GET /products?title=produktoPavadinimasPaieskai - sugrąžina produktų sąrašą kurių pavadinimai sutampa
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Užduotis 1 produktų administravimas

                - Paprastumo dėlei produktą apibrėžia 2 laukai
                  - id - unikalus produkto id generuojamas išsaugojimo mechanizmo
                  - title - produkto pavadinimas
                - Išlaikykite `@Service`, `@Controller`, `@Repository` atskyrimus
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Sąryšiai

                - Kaip ir duomenų bazėses taip ir objektiniame modelyje sąryšiai būna trijų tipų
                  - Vienas su vienu (One to one)
                  - Vienas su daug (One to many)
                  - Daug su daug (Many to Many)
                - Reliaciniame modelyje visi sąryšiai yra iškart abipusiai
                - Objektiniame modelyje gali būti vienpusiai arba abipusiai
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Sąryšių valdymas (cascade type)

                - Kiekvieno sąryšio anotacija turi atributą `cascadeType`
                - Priklausomai nuo operacijos: PERSIST, MERGE, REMOVE, REFRESH, ALL
                - Nenurodžius PERSIST tipo saugant objektą jo sąryšiai nebus išsaugoti duomenų bazėje
                - Norint autmoatiškai deleguoti operacijos vaikiniams objektams - ALL
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Sąryšiai - OneToOne

                ```
                @Entity
                public class ProductEntity {
                    @OneToOne(cascade = CascadeType.ALL)
                    private ProductDetail details;

                }
                ```
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Sąryšiai - OneToOne - bidirectinal

                ```
                @Entity
                public class ProductDetailsEntity {
                    private String details;
                    @OneToOne(mappedBy = "details")
                    private ProductEntity product;
                }
                ```

                Abipusio sąryšio atveju `mappedBy` atributas nurodo `owner` klasės lauko pavadinimą.
                Pabandykit jo nenurodyti ir pažiūrėkite kaip atrodo neužkrautas objektas iš DB.
                Pabandykite nurodyti `owner` klasėje
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Sąryšiai - OneToMany

                ```
                @Entity
                public class ProductEntity {
                    @OneToMany(cascade = CascadeType.ALL, mappedBy = "product")
                    private List<ProductSpecEntity> specifications;
                }
                ```
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Sąryšiai - OneToMany/ManyToOne

                ```
                @Entity
                public class ProductSpecEntity {
                    @ManyToOne
                    private ProductEntity product;
                }
                ```

                Atvirkščiai nei `OneToOne` atveju `mappedBy` yra `owner` klasėje. Kodėl?
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Sąryšiai - ManyToMany

                ```
                @Entity
                public class CartEntity {
                    @ManyToMany
                    private List<ProductEntity> products;
                }
                ```


            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Sąryšiai - ManyToMany bidirectinal

                ```
                @Entity
                public class ProductEntity {
                    @ManyToMany(mappedBy = "products")
                    private List<CartEntity> carts;
                }
                ```

                Kaip ir ManyToOne atveju nurodomas `mappedBy` atributas.
                Kas būtų jei nurodytume `mappedBy` CartEntity klasėje?
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Sąryšiai - ManyToMany pastabos

                - Svarbu kur yra `mappedBy` atributas
                - mūsų pavyzdyje Hibernate seks atnaujinimus tiktai `cart.products` kolekcijai
                - jeigu papildysime tiktai `product.carts` kolekciją duomenų bazėje tai neatsispindės, nes `owner`
                klasė yra `CartEntity`
                - todėl programuotojas pats turi užtikrinti korektišką pridėjima:
                ```
                product.carts.add(cart);
                //Only this modification will trigger db updates
                cart.products.add(product);
                ```
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Užduotis 2 Sumodeliuokite vienas su vienu sąryšį

                - Kiekvienas produktas turi produkto detales
                - Detalės yra sudėtingas darinys todėl prasminga jas saugoti atskiroje klasėje
                - Paprastumo dėlei detales aprašo vienas String tipo laukas
                - Užtikrinkite, kad išsaugojus produktą jo detalės išsisaugo taip pat
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Užduotis 3 Sumodeliuokite vienas su daug

                - Kiekvienas produktas turi specifikacijos įrašus
                - Paprastumo dėlei specifikacija aprašo pavadinimas ir reikšmė
                  - Ektrano dydis: 20x20
                - Užtikrinkite, kad saugant produktą išsaugomos ir jo specifikacijos
                - Užtikrinkite, kad atnaujinant produkto specifikacijas jos teisingai atsinaujina
                  - trinsai, atsinaujina, kuriasi
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### Užduotis 4 Sumodeliuokite daug su daug sąryšį

                - Modeliuosime prekių krepšelį
                - Ta pati prekė gali priklausyti keliems krepšeliams
                - Viename krepšelyje gali būti daug prekių
                - Krepšelis gali turėti sukūrimo datą, atnaujinimo datą
                  - Sukūrimo ir atnaujinimo datos negali būti pakeistos vartotojų
            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
                #### TODO slides in progress

            </script>
        </section>
        <section data-markdown data-background-image="sbg.png">
            <script type="text/template">
              Pabaiga

              ![jesus](jezus.jpg "jesus")
            </script>
        </section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
        controls: false,
				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});

      Reveal.configure({ slideNumber: 'c' });
		</script>
	</body>
</html>
